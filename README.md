# 学习java

# 2020.6.8
      数据类型容量：  byte 、char 、short  ---> int ---> long ---> float ---> double
                  当byte 、char 、short三种类型互相做运算时，结果需要至少int型
# 2020.6.9
      String 类型定义变量必须是双引号 String name = "lmz"  ; Char类型定义变量必须是单引号 Char x = 'L'
      二进制 0，1                  例子： 01   (最大数<2)
      八进制 0-7  以0开头          例子： 0123 (最大数<8）
      十进制 0-9                   例子： 123
      十六进制 0-9及A-F  以0x开头  例子： 满16进1 --> 0x21AF + 1 = 0X21B0
      二进制转换为十进制的简便算法  00001110 -->   1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 14 （符号位不参与运算）
      十进制转换为二进制的算法(除2取余数然后逆序) 
                      例子：  13/2-->商6余1-->6/2-->商3余0-->3/2-->商1余1--->1/2-->商0余1-->0/2-->商0余0--》···
                                        1              0                1            1              0       ··
                                然后逆序    00001101        
      二进制数又分为正数和负数 ，区分的方式就是符号位是0还是1  0就表示正数 1就表示负数（这里的符号位是指从右往左数的第8位）
      二进制正数如何转换为负数：
               例子:                    0 0 0 0 1 1 1 0        （14）
               第一步: 符号位变为1       1 0 0 0 1 1 1 0        (称为 -14的原码）
               第二步：除符号位外取反    1 1 1 1 0 0 0 1        （称为-14的反码）
               第三步：反码加 1          1 1 1 1 0 0 1 0        （称为-14的补码）
                得出的补码即为某整二进制数的对应负数
# 2020.6.10
      位运算符  <<左移  >>右移
         计算方法   21 << 2 ，表示21左移2位，此时的数变为了 21 * 2^2   -->84
# 2020.6.11
       程序流程控制：：顺序机构、分支结构、循环结构
       当有多个if else 且没有大括号括起来   if和else默认就近原则
       math.random() : 介于 0（包含） ~ 1（不包含） 之间的一个随机数 
       获取一个随机数
                [a,b)       math.random() * (b-a) + a
                [a,b]       math.random() * (b-a+1) + a
# 2020.6.12
    for循环的真实执行顺序
      :     int num =1;
            for(system.out.print('a);   num<=3;    system.out.print('c'),num++){
                   // 语句1              语句2                语句3
                  system.out.print('b')   //语句4
            }
            输出： a b c b c b c  （语句1-->语句2--(满足条件)语句4 -->语句3 -->语句2 ······）
# 2020.6.17
     数组一经定义，长度不可再变
# 2020.6.29
     学习了二维数组的一些属性
         1.  int[][] arr = new int[3][2]
             system.out.println(arr[1])  //是一个地址值（因为都是堆栈存储 ，栈内存储地址值）
             system.out.println(arr[1][1])  //0    此处的值根据声明数组的类型决定  new float：0.0   new boolean:false  new string:null 
         2.  int [][] arr = new int[3][]
             system.out.println(arr[1])  // null
             system.out.println(arr[1][1]) //报错了
         3. int[] x  ===  int x[] 
            int[][] y ===  int[] y[]  === int y[][]          
     
# 2020.7.3
     属性（局部变量）因为有默认隐式赋值，就不需要显式赋值了
     局部变量必须要显式赋值
# 2020.7.9
      方法的重载： 在同一个类中，允许出现一个以上同名的方法，只要它们的参数个数或者参数类型不同即可。
# 2020.7.10
      方法的形参的传递机制是什么：值传递机制
            如果方法的参数传递的是基本数据类型，那么实参赋值给形参的是真实的数据值
            如果方法的参数传递的是引用数据类型，那么实参赋值给形参的是数据的地址值
# 2020.7.14
     String s1 = "hello"  
         : s1是一个引用数据类型而不是基本数据类型，这里说明String是一个比较特殊的类
# 2020.7.15
      面向对象的三大特性：  继承 封装 多态
      封装性的体现之一  ：  类的属性设置private私有化，对外暴露可以获取(get)和设置(set)私有属性的public方法
      java规定的四种权限（从小到大）：  private  缺省  protected   public
      修饰类的权限修饰符只能用缺省或者public,而类中的内部结构可以由4种修饰符任意一个修饰
      类的成员： 属性 方法 构造器(构造方法，每一个类都有构造器)
      构造器的作用：  
            Person p = new Person();   
            Person()就是一个构造器   作用  1.创建一个对象  2.给对象进行初始化赋值
# 2020.7.20
     默认构造器的权限取决于定义类时的权限修饰符
# 2020.7.27
     for(;;){
         //不加条件的for循环，则一直处于循环状态
         if(true){
             break  //只有break可以退出该循环
         }else{
            return ;   //return是退出当次循环
         }
        
     }
# 2020.7.29
    继承性的一些特征
        ： 子类A继承父类B后，子类A中就获取了父类B中声明的所有的属性和方法。父类中一些private的属性或方法，子类仍然获取得到，只是因为封装
       性的影响，使得子类不能直接调用父类的结构而已

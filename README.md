# 学习java

# 2020.6.8
      数据类型容量：  byte 、char 、short  ---> int ---> long ---> float ---> double
                  当byte 、char 、short三种类型互相做运算时，结果需要至少int型
# 2020.6.9
      String 类型定义变量必须是双引号 String name = "lmz"  ; Char类型定义变量必须是单引号 Char x = 'L'
      二进制 0，1                  例子： 01   (最大数<2)
      八进制 0-7  以0开头          例子： 0123 (最大数<8）
      十进制 0-9                   例子： 123
      十六进制 0-9及A-F  以0x开头  例子： 满16进1 --> 0x21AF + 1 = 0X21B0
      二进制转换为十进制的简便算法  00001110 -->   1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 14 （符号位不参与运算）
      十进制转换为二进制的算法(除2取余数然后逆序) 
                      例子：  13/2-->商6余1-->6/2-->商3余0-->3/2-->商1余1--->1/2-->商0余1-->0/2-->商0余0--》···
                                        1              0                1            1              0       ··
                                然后逆序    00001101        
      二进制数又分为正数和负数 ，区分的方式就是符号位是0还是1  0就表示正数 1就表示负数（这里的符号位是指从右往左数的第8位）
      二进制正数如何转换为负数：
               例子:                    0 0 0 0 1 1 1 0        （14）
               第一步: 符号位变为1       1 0 0 0 1 1 1 0        (称为 -14的原码）
               第二步：除符号位外取反    1 1 1 1 0 0 0 1        （称为-14的反码）
               第三步：反码加 1          1 1 1 1 0 0 1 0        （称为-14的补码）
                得出的补码即为某整二进制数的对应负数
# 2020.6.10
      位运算符  <<左移  >>右移
         计算方法   21 << 2 ，表示21左移2位，此时的数变为了 21 * 2^2   -->84
# 2020.6.11
       程序流程控制：：顺序机构、分支结构、循环结构
       当有多个if else 且没有大括号括起来   if和else默认就近原则
       math.random() : 介于 0（包含） ~ 1（不包含） 之间的一个随机数 
       获取一个随机数
                [a,b)       math.random() * (b-a) + a
                [a,b]       math.random() * (b-a+1) + a
# 2020.6.12
    for循环的真实执行顺序
      :     int num =1;
            for(system.out.print('a);   num<=3;    system.out.print('c'),num++){
                   // 语句1              语句2                语句3
                  system.out.print('b')   //语句4
            }
            输出： a b c b c b c  （语句1-->语句2--(满足条件)语句4 -->语句3 -->语句2 ······）
# 2020.6.17
     数组一经定义，长度不可再变
# 2020.6.29
     学习了二维数组的一些属性
         1.  int[][] arr = new int[3][2]
             system.out.println(arr[1])  //是一个地址值（因为都是堆栈存储 ，栈内存储地址值）
             system.out.println(arr[1][1])  //0    此处的值根据声明数组的类型决定  new float：0.0   new boolean:false  new string:null 
         2.  int [][] arr = new int[3][]
             system.out.println(arr[1])  // null
             system.out.println(arr[1][1]) //报错了
         3. int[] x  ===  int x[] 
            int[][] y ===  int[] y[]  === int y[][]          
     
# 2020.7.3
     属性（局部变量）因为有默认隐式赋值，就不需要显式赋值了
     局部变量必须要显式赋值
# 2020.7.9
      方法的重载： 在同一个类中，允许出现一个以上同名的方法，只要它们的参数个数或者参数类型不同即可。
# 2020.7.10
      方法的形参的传递机制是什么：值传递机制
            如果方法的参数传递的是基本数据类型，那么实参赋值给形参的是真实的数据值
            如果方法的参数传递的是引用数据类型，那么实参赋值给形参的是数据的地址值
# 2020.7.14
     String s1 = "hello"  
         : s1是一个引用数据类型而不是基本数据类型，这里说明String是一个比较特殊的类
# 2020.7.15
      面向对象的三大特性：  继承 封装 多态
      封装性的体现之一  ：  类的属性设置private私有化，对外暴露可以获取(get)和设置(set)私有属性的public方法
      java规定的四种权限（从小到大）：  private  缺省  protected   public
      修饰类的权限修饰符只能用缺省或者public,而类中的内部结构可以由4种修饰符任意一个修饰
      类的成员： 属性 方法 构造器(构造方法，每一个类都有构造器)
      构造器的作用：  
            Person p = new Person();   
            Person()就是一个构造器   作用  1.创建一个对象  2.给对象进行初始化赋值
# 2020.7.20
     默认构造器的权限取决于定义类时的权限修饰符
# 2020.7.27
     for(;;){
         //不加条件的for循环，则一直处于循环状态
         if(true){
             break  //只有break可以退出该循环
         }else{
            return ;   //return是退出当次循环
         }
        
     }
# 2020.7.29
    继承性的一些特征
           ： 子类A继承父类B后，子类A中就获取了父类B中声明的所有的属性和方法。父类中一些private的属性或方法，子类仍然获取得到，只是因为封装
       性的影响，使得子类不能直接调用父类的结构而已
    方法的重写ovveride/overwrite?
           :   1. 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
               2. 子类不能重写父类中使用private权限修饰符声明的方法
# 2020.7.31
     super关键字相关
         ： 在构造器中使用this(形参列表)，表示调用本类中符合形参列表格式的构造器；
                    而使用super(形参列表)，表示调用父类符合形参列表格式的构造器；
            this(name) 和 super(name)要求都必须写在第一行，所以二者不可同时出现
            如果类中的构造器没有显示的使用this(形参列表）或者super(形参列表）,则默认调用了父类中空参的构造器即super();
     多态？
           ：对象的多态性---父类的引用指向子类的对象
              Person p1 = new Man();
              在程序编译期，p1只能执行父类中声明过的方法，但在程序执行时，p1调用的却是子类中重写的方法
     多态性的使用前提？
              ：1. 类的继承关系
                2.  方法的重写
# 2020.8.3
      多态性的使用举例
              ： public void test(Animal anima){
                     animal.eat();
                     animal.shout();
                 }
                当dog类调用test方法是，输出 狗：进食 汪汪汪！
                当cat类调用test方法时，输出 猫：进食 喵喵喵！
                这是多态的一个作用，若没有多态性，那么此方法的参数必须是Animal类，而不可以是其子类dog或cat,
                并且dog要去调用dog类上的test方法，cat要去调用cat类上的方法，代码冗杂
        多态性只适用于方法，不适用于属性变量，即变量不存在多态性

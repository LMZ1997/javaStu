# 学习java

# 2020.6.8
      数据类型容量：  byte 、char 、short  ---> int ---> long ---> float ---> double
                  当byte 、char 、short三种类型互相做运算时，结果需要至少int型
# 2020.6.9
      String 类型定义变量必须是双引号 String name = "lmz"  ; Char类型定义变量必须是单引号 Char x = 'L'
      二进制 0，1                  例子： 01   (最大数<2)
      八进制 0-7  以0开头          例子： 0123 (最大数<8）
      十进制 0-9                   例子： 123
      十六进制 0-9及A-F  以0x开头  例子： 满16进1 --> 0x21AF + 1 = 0X21B0
      二进制转换为十进制的简便算法  00001110 -->   1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 14 （符号位不参与运算）
      十进制转换为二进制的算法(除2取余数然后逆序) 
                      例子：  13/2-->商6余1-->6/2-->商3余0-->3/2-->商1余1--->1/2-->商0余1-->0/2-->商0余0--》···
                                        1              0                1            1              0       ··
                                然后逆序    00001101        
      二进制数又分为正数和负数 ，区分的方式就是符号位是0还是1  0就表示正数 1就表示负数（这里的符号位是指从右往左数的第8位）
      二进制正数如何转换为负数：
               例子:                    0 0 0 0 1 1 1 0        （14）
               第一步: 符号位变为1       1 0 0 0 1 1 1 0        (称为 -14的原码）
               第二步：除符号位外取反    1 1 1 1 0 0 0 1        （称为-14的反码）
               第三步：反码加 1          1 1 1 1 0 0 1 0        （称为-14的补码）
                得出的补码即为某整二进制数的对应负数
# 2020.6.10
      位运算符  <<左移  >>右移
         计算方法   21 << 2 ，表示21左移2位，此时的数变为了 21 * 2^2   -->84
# 2020.6.11
       程序流程控制：：顺序机构、分支结构、循环结构
       当有多个if else 且没有大括号括起来   if和else默认就近原则
       math.random() : 介于 0（包含） ~ 1（不包含） 之间的一个随机数 
       获取一个随机数
                [a,b)       math.random() * (b-a) + a
                [a,b]       math.random() * (b-a+1) + a
# 2020.6.12
    for循环的真实执行顺序
      :     int num =1;
            for(system.out.print('a);   num<=3;    system.out.print('c'),num++){
                   // 语句1              语句2                语句3
                  system.out.print('b')   //语句4
            }
            输出： a b c b c b c  （语句1-->语句2--(满足条件)语句4 -->语句3 -->语句2 ······）
# 2020.6.17
     数组一经定义，长度不可再变
# 2020.6.29
     学习了二维数组的一些属性
         1.  int[][] arr = new int[3][2]
             system.out.println(arr[1])  //是一个地址值（因为都是堆栈存储 ，栈内存储地址值）
             system.out.println(arr[1][1])  //0    此处的值根据声明数组的类型决定  new float：0.0   new boolean:false  new string:null 
         2.  int [][] arr = new int[3][]
             system.out.println(arr[1])  // null
             system.out.println(arr[1][1]) //报错了
         3. int[] x  ===  int x[] 
            int[][] y ===  int[] y[]  === int y[][]          
     
# 2020.7.3
     属性（局部变量）因为有默认隐式赋值，就不需要显式赋值了
     局部变量必须要显式赋值
# 2020.7.9
      方法的重载： 在同一个类中，允许出现一个以上同名的方法，只要它们的参数个数或者参数类型不同即可。
# 2020.7.10
      方法的形参的传递机制是什么：值传递机制
            如果方法的参数传递的是基本数据类型，那么实参赋值给形参的是真实的数据值
            如果方法的参数传递的是引用数据类型，那么实参赋值给形参的是数据的地址值
# 2020.7.14
     String s1 = "hello"  
         : s1是一个引用数据类型而不是基本数据类型，这里说明String是一个比较特殊的类
# 2020.7.15
      面向对象的三大特性：  继承 封装 多态
      封装性的体现之一  ：  类的属性设置private私有化，对外暴露可以获取(get)和设置(set)私有属性的public方法
      java规定的四种权限（从小到大）：  private  缺省  protected   public
      修饰类的权限修饰符只能用缺省或者public,而类中的内部结构可以由4种修饰符任意一个修饰
      类的成员： 属性 方法 构造器(构造方法，每一个类都有构造器)
      构造器的作用：  
            Person p = new Person();   
            Person()就是一个构造器   作用  1.创建一个对象  2.给对象进行初始化赋值
# 2020.7.20
     默认构造器的权限取决于定义类时的权限修饰符
# 2020.7.27
     for(;;){
         //不加条件的for循环，则一直处于循环状态
         if(true){
             break  //只有break可以退出该循环
         }else{
            return ;   //return是退出当次循环
         }
        
     }
# 2020.7.29
    继承性的一些特征
           ： 子类A继承父类B后，子类A中就获取了父类B中声明的所有的属性和方法。父类中一些private的属性或方法，子类仍然获取得到，只是因为封装
       性的影响，使得子类不能直接调用父类的结构而已
    方法的重写ovveride/overwrite?
           :   1. 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
               2. 子类不能重写父类中使用private权限修饰符声明的方法
# 2020.7.31
     super关键字相关
         ： 在构造器中使用this(形参列表)，表示调用本类中符合形参列表格式的构造器；
                    而使用super(形参列表)，表示调用父类符合形参列表格式的构造器；
            this(name) 和 super(name)要求都必须写在第一行，所以二者不可同时出现
            如果类中的构造器没有显示的使用this(形参列表）或者super(形参列表）,则默认调用了父类中空参的构造器即super();
     多态？
           ：对象的多态性---父类的引用指向子类的对象
              Person p1 = new Man();
              在程序编译期，p1只能执行父类中声明过的方法，但在程序执行时，p1调用的却是子类中重写的方法
     多态性的使用前提？
              ：1. 类的继承关系
                2.  方法的重写
# 2020.8.3
      多态性的使用举例
              ： public void test(Animal anima){
                     animal.eat();
                     animal.shout();
                 }
                当dog类调用test方法是，输出 狗：进食 汪汪汪！
                当cat类调用test方法时，输出 猫：进食 喵喵喵！
                这是多态的一个作用，若没有多态性，那么此方法的参数必须是Animal类，而不可以是其子类dog或cat,
                并且dog要去调用dog类上的test方法，cat要去调用cat类上的方法，代码冗杂
        多态性只适用于方法，不适用于属性变量，即变量不存在多态性
# 2020.8.5
        equals()方法？
            ：比较对象的实体内容是否相等
              注意点：若是自己写的类，那么调用equals()方法，是继承自Object类的方法，此时比较的是对象的地址值，类似于==
                      而java封装的类如String Date等，equal()方法是经过重写的，此时比较的才是实体内容
                    所以，若是自定义的类需要使用equal()的话，就需要在类中重写，默认提供了一键重写
# 2020.8.6
      java中两个字符串的比较
        ：   String s1 = 'AA';
             String s1 = 'AA';
             system.out.println(s1 == s2) ;  //true  虽然String是引用类型，但是这样声明的字符串还是相等的

             s1 = 'BB'
             system.out.print(s2) //'AA'
      当syso一个对象实例的时候，其实是syso对象实例.toString()
      如何创建一个单元测试？
           详细步骤：    1. 选中当前工程 --右键选择 build path -- add libraries -- Junit 4 -- 下一步
                         2. 创建类（public 无参构造器）
                         3. 创建单元测试方法 （public 、 void 、无参）
                         4. 在方法前声明注解 ： @Test   (需import相关包）
                         5. 测试时 -- 双击方法名，右键选择 Run as -Junit test
           简单步骤：    在需要单元测试的地方(需要保证类的条件)，直接写上@Test 并且写上测试方法，此时会有错误，点击需要的操
                      作，系统自己会执行一系列步骤
     基本数据类型与包装类之间的相互转换
           ： 1. 基本数据类型-->包装类  ：  用 new + 类(某个值)    如：int num1 = 2 ; Interge obj1 = new Interge(num1)
              2. 包装类 ---> 基本数据类型  ： 用obj1.xxxValue()    如：int num2 = obj1.intValue()
              自动拆箱与自动装箱可以简化以上过程   如 ： int num3 = obj1 实际就等于 int num3 = obj1.intValue()
              3.String与二者的相互转换    String s = "123"
                  String --> 基本类型或包装类   
                      类.parseXxx()   如：int i = Interge.parseInt(s)
                  基本类型 -->  String
                     String.valueof()   如： String s1 = String.valueof(i)
# 2020.8.7
        satic声明的属性或方法是所有实例可以共享的，非static声明的变量称为实例变量，
         静态方法（static声明的方法）内部只能使用静态方法或静态属性，不可以使用非静态方法或属性；非静态方法可以随便调用  
         静态方法不能使用this关键字
         this()表示本类中的无参构造器，super代表父类的无参构造器
         单例模式：
               对某个类来说只存在一个对象实例
         静态属性、静态方法、静/非静态代码块之间的关系？
              ： 静态属性、静态方法随着类的加载而加载 ，静态代码块会随着类的加载而执行，非静态代码块随着对象的创建而执行
                 静态代码块内部只能调用静态属性或方法，非静态代码块可以随意调用
# 2020.8.10
       静态代码块、非静态代码块、构造器之间的执行顺序？
              ：由父及子，静态先行
           注意：由于main方法也是类中的一个静态方法，要想执行它，肯定是先加载好类，所以非静态代码块也在main方法前执行
       final关键字的作用？
             ：1. 当final修饰一个类时，表示这个类不能再被其他类继承了
               2. 当final修饰一个方法时，表示这个方法不能再被重写了
               3.当final修饰一个变量时，表示这个变量不能再被二次赋值了
             
# 2020.8.11
         抽象类的说明
             ：abstract修饰类 ->抽象类（不能再new实例了）
              abstract修饰方法 ->抽象方法
              包含抽象方法的类一定是一个抽象类，因为抽象方法不可以被调用，怎么让它不被调用呢，就是让类不可以造对象
          举一个抽象类及抽象方法的运用场景
              ：    首先声明一个代表几何图形的类，然后声明一个方法求其面积，因为不知道这个几何图形到底是什么图形，那么没有固定求面积的公式，
                 那这时怎么声明此方法呢，就是用abstract抽象声明该方法，当创建一个三角形继承自该几何图形类时，到了具体的图形，求面积方法就
                 可以固定了，那么在三角形类中重写求面积的方法即可
          abstract关键字使用的注意点？
              :abstract不能用来修饰哪些地方
                   1.私有方法
                       因为既然一个方法用abstract修饰，那表明在子类中是需要重写的，这时若此方法还使用private修饰，那么
                       子类获取不到，又何来重写一说
                   2. 静态方法
                       因为static声明的方法，就算子父类中同名同参，那么也不叫重写，所以不能共同使用
                   3. final方法
                       final方法不能重写，同1
                   4. final的类
                       final的类都不能继承，如果还用abstract修饰的话，自身又不能new对象，那搞它干嘛
# 2020.8.12
       如何创建一个匿名子类的实例对象？
              //匿名类肯定是子类
             Person p = new Person(){
                 //方法体里需要重写父类(Person)中的抽象方法
             }
# 2020.8.13
       interface关键字？
             ：用来描述一类事物拥有共同的行为特征
                  >例如：鸟 飞机 子弹   共同特征：会飞
               在JDK7之前：只能声明全局常量及抽象方法
                  ：1. public static final int NUM = 1  因为在interface中写法是固定的，所以默认可以省略 public static final这三个修饰符
                    2. public abstract void fly()       因为在interface中写法是固定的，所以默认可以省略public abstract这两个修饰符
     如何实现接口？（使用implements关键字）
            ：通过实现接口，可以使对应的类拥有接口的行为特征
             class plane implements 接口名称{ 
                //重写对应的抽象方法，否则此类也必须声明为抽象类  
             }
     java类具有单继承性，但是接口却可以同时implements多个，用逗号隔开,并且类可以同时extends和implements
         > class A extends b implements C,D,E
      接口之间也可以使用extends继承，并且支持多继承，即一个接口继承自多个接口
